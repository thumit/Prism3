---------------------------------------------------------LOGIC CHECK-------------------------------------------------------

----------
1.0. check existing_strata for duplication
SELECT  
COUNT (strata_id) as total_strata, 
COUNT (DISTINCT strata_id) as total_unique_strata,
CASE WHEN COUNT (strata_id) = COUNT (DISTINCT strata_id) THEN 'none - data is good' ELSE 'review - duplicated strata exist' end AS recommended_action
FROM  
(SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata)
----------
1.1. list all duplicated existing_strata
SELECT 
(layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, COUNT(*) as count
FROM existing_strata
GROUP BY strata_id HAVING COUNT(*) > 1
----------
----------------------------------------------------EVEN AGE ROTATION------------------------------------------------

----------
2.0. rotation age ranges for existing forest by cover type & size class
SELECT
Covertype,
Sizeclass,
MIN(CAST(rotation_age as INTEGER)) AS E_min_rotation_age, 
MAX(CAST(rotation_age as INTEGER)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_1' GROUP BY prescription)
)
)
)
)



GROUP BY Covertype, Sizeclass
----------
2.1. rotation age ranges for existing forest by cover type
SELECT
Covertype as E_covertype,
MIN(CAST(rotation_age as INTEGER)) AS E_min_rotation_age, 
MAX(CAST(rotation_age as INTEGER)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_1' GROUP BY prescription)
)
)
)



GROUP BY Covertype
----------
2.2. rotation age ranges for regenerated forest by cover type
SELECT
Covertype as R_covertype,
MIN(CAST(rotation_age as INTEGER)) AS R_min_rotation_age, 
MAX(CAST(rotation_age as INTEGER)) AS R_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'R_1' GROUP BY prescription)
)
)
)



GROUP BY Covertype
----------
2.3. rotation age ranges for existing forest and regenerated forest by cover type (full outer join of 2.1 & 2.2)
SELECT
e_table.Covertype,
e_table.E_min_rotation_age,
e_table.E_max_rotation_age,
r_table.R_min_rotation_age,
r_table.R_max_rotation_age
FROM
(




(SELECT
Covertype,
MIN(CAST(rotation_age AS INTEGER)) AS E_min_rotation_age, 
MAX(CAST(rotation_age AS INTEGER)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_1' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS e_table


LEFT JOIN


(SELECT
Covertype,
MIN(CAST(rotation_age AS INTEGER)) AS R_min_rotation_age, 
MAX(CAST(rotation_age AS INTEGER)) AS R_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class AS INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'R_1' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS r_table


ON e_table.Covertype = r_table.Covertype)





UNION ALL





SELECT
r_table.Covertype,
e_table.E_min_rotation_age,
e_table.E_max_rotation_age,
r_table.R_min_rotation_age,
r_table.R_max_rotation_age
FROM
(


(SELECT
Covertype,
MIN(CAST(rotation_age AS INTEGER)) AS R_min_rotation_age, 
MAX(CAST(rotation_age AS INTEGER)) AS R_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class AS INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'R_1' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS r_table


LEFT JOIN


(SELECT
Covertype,
MIN(CAST(rotation_age AS INTEGER)) AS E_min_rotation_age, 
MAX(CAST(rotation_age AS INTEGER)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) AS Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) AS Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) AS Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) AS Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_1' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS e_table


ON e_table.Covertype = r_table.Covertype)





WHERE  e_table.Covertype IS NULL
----------
---------------------------------------------------PRESCRIPTION COUNT-----------------------------------------------

----------
3.0. count total number of prescriptions for existing forest by cover type, size class
SELECT
Covertype,
Sizeclass,
SUM(CASE when Status = 'E' AND Clearcut = '0' then 1 else 0 end) E_0_Prescriptions,
SUM(CASE when Status = 'E' AND Clearcut = '1' then 1 else 0 end) E_1_Prescriptions,
SUM(1) Total_Prescriptions
FROM



(
SELECT
Status,
Clearcut,
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Status,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_0' OR SUBSTR(prescription, 1, 3) = 'E_1')
)
)
)
)



GROUP BY
Covertype,
Sizeclass




UNION ALL

SELECT
'Total_Prescriptions' as CoverType2,
'' as SizeClass2,
SUM(case when SUBSTR(prescription, 1, 3) = 'E_0' then 1 else 0 end) E_0,
SUM(case when SUBSTR(prescription, 1, 3) = 'E_1' then 1 else 0 end) E_1,
SUM(case when SUBSTR(prescription, 1, 2) = 'E_' then 1 else 0 end) Total_Prescriptions
FROM (SELECT DISTINCT prescription FROM yield_tables)
----------
3.1. count total number of prescriptions for existing forest and regenerated forest by cover type
SELECT
SUBSTR(DISTINCT prescription, 5, INSTR(DISTINCT prescription, "_")-1) as CoverType,
SUM(case when SUBSTR(prescription, 1, 3) = 'E_0' then 1 else 0 end) E_0_Prescriptions,
SUM(case when SUBSTR(prescription, 1, 3) = 'E_1' then 1 else 0 end) E_1_Prescriptions,
SUM(case when SUBSTR(prescription, 1, 3) = 'R_0' then 1 else 0 end) R_0_Prescriptions,
SUM(case when SUBSTR(prescription, 1, 3) = 'R_1' then 1 else 0 end) R_1_Prescriptions,
SUM(case when prescription LIKE '%%' then 1 else 0 end) Total_Prescriptions
FROM (SELECT DISTINCT prescription FROM yield_tables)
GROUP BY CoverType

UNION ALL

SELECT
'Total_Prescriptions' as CoverType2,
SUM(case when SUBSTR(prescription, 1, 3) = 'E_0' then 1 else 0 end) E_0_Prescriptions,
SUM(case when SUBSTR(prescription, 1, 3) = 'E_1' then 1 else 0 end) E_1_Prescriptions,
SUM(case when SUBSTR(prescription, 1, 3) = 'R_0' then 1 else 0 end) R_0_Prescriptions,
SUM(case when SUBSTR(prescription, 1, 3) = 'R_1' then 1 else 0 end) R_1_Prescriptions,
SUM(case when prescription LIKE '%%' then 1 else 0 end) Total_Prescriptions
FROM (SELECT DISTINCT prescription FROM yield_tables)
----------
-----------------------------------------------------PRESCRIPTION LIST-------------------------------------------------

----------
4.0. List all prescriptions
SELECT
DISTINCT prescription,
activity AS final_activity,
MIN(CAST(age_class as INTEGER)) AS min_age_class,
MAX(CAST(age_class as INTEGER)) AS max_age_class,
COUNT(activity) AS total_rows
FROM yield_tables
GROUP BY prescription
----------
4.1. List uneven-aged prescriptions for existing forest
SELECT
DISTINCT prescription,
activity AS final_activity,
MIN(CAST(age_class as INTEGER)) AS min_age_class,
MAX(CAST(age_class as INTEGER)) AS max_age_class,
COUNT(activity) AS total_rows
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_0' 
GROUP BY prescription
----------
4.2. List uneven-aged prescriptions for regenerated forest
SELECT
DISTINCT prescription,
activity AS final_activity,
MIN(CAST(age_class as INTEGER)) AS min_age_class,
MAX(CAST(age_class as INTEGER)) AS max_age_class,
COUNT(activity) AS total_rows
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'R_0' 
GROUP BY prescription
----------
4.3. List even-aged prescriptions for existing forest
SELECT
DISTINCT prescription,
activity AS final_activity,
MIN(CAST(age_class as INTEGER)) AS min_age_class,
MAX(CAST(age_class as INTEGER)) AS max_age_class,
COUNT(activity) AS total_rows
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'E_1' 
GROUP BY prescription
----------
4.3. List even-aged prescriptions for regenerated forest
SELECT
DISTINCT prescription,
activity AS final_activity,
MIN(CAST(age_class as INTEGER)) AS min_age_class,
MAX(CAST(age_class as INTEGER)) AS max_age_class,
COUNT(activity) AS total_rows
FROM yield_tables
WHERE SUBSTR(prescription, 1, 3) = 'R_1' 
GROUP BY prescription
----------