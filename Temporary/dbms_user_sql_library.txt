test join 1
SELECT *
FROM output_05_management_details
INNER JOIN yield_tables
ON output_05_management_details.prescription = yield_tables.prescription AND output_05_management_details.row_id = yield_tables.row_id
----------
test join 2
SELECT output_05_management_details.prescription
FROM output_05_management_details
INNER JOIN yield_tables
ON output_05_management_details.prescription = yield_tables.prescription AND output_05_management_details.row_id = yield_tables.row_id
----------
vacuum
vacuum
----------
other test
SELECT
SUBSTR(prescription, 1, INSTR(prescription, "_")-1) as CoverType,
vegt

FROM yield_tables
----------
compare cover type
SELECT
SUBSTR(prescription, 1, INSTR(prescription, "_")-1) as prescription_vegt, vegt,

CASE WHEN SUBSTR(prescription, 1, INSTR(prescription, "_")-1) = vegt then 'correct' else 'fail' end AS Compare

From yield_tables;
----------
check MS prescriptions with a few information
select prescription, row_id, age_class, age, qmd, action_type from yield_tables where prescription Like '%_MS_E%'
----------
rename column row_id to row
ALTER TABLE yield_tables RENAME COLUMN row_id TO row
----------
test strata check 1 (future use in read_existig_strata)
SELECT  
COUNT (strata_id) as total_strata, 
COUNT (DISTINCT strata_id) as total_unique_strata,
CASE WHEN COUNT (strata_id) = COUNT (DISTINCT strata_id) THEN 'none - data is good' ELSE 'review duplicated strata' end AS recommendation
FROM  
(SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata)
----------
test strata check 2 (future use in : SQL library for dbms)
SELECT 
(layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, COUNT(*) as count
FROM existing_strata
GROUP BY strata_id HAVING COUNT(*) > 1
----------
test count existing_strata (simple, no use in read_existig_strata)
SELECT  COUNT (DISTINCT strata_id) as total_unique_strata
FROM  (SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata)
----------
test3 strata
SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, acres FROM  existing_strata ORDER BY (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) ASC;
----------
test-read existing strata 1
SELECT COUNT (DISTINCT strata_id) FROM (SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata);
----------
test-read existing strata 2
SELECT * FROM existing_strata ORDER BY (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) ASC;
----------
test substring
SELECT
SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1) as CoverType,

SUBSTR(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_"))), 1, INSTR(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_"))), "_")-1) as SizeClass,

SUM(case when prescription LIKE '%\_NG\_E%' ESCAPE '\' then 1 else 0 end) NG_E,
SUM(case when prescription LIKE '%\_PB\_E%' ESCAPE '\' then 1 else 0 end) PB_E,
SUM(case when prescription LIKE '%\_GS\_E%' ESCAPE '\' then 1 else 0 end) GS_E,
SUM(case when prescription LIKE '%\_EA\_E%' ESCAPE '\' then 1 else 0 end) EA_E,
SUM(case when prescription LIKE '%\_MS\_E%' ESCAPE '\' then 1 else 0 end) MS_E,
SUM(case when prescription LIKE '%\_BS\_E%' ESCAPE '\' then 1 else 0 end) BS_E,
SUM(case when SUBSTR(DISTINCT prescription, 8, INSTR(DISTINCT prescription, "_")-1) LIKE 'E' then 1 else 0 end) Total_Prescriptions
FROM 
(SELECT DISTINCT prescription FROM yield_tables
WHERE prescription LIKE '%\_NG\_E%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E%' ESCAPE '\' )
GROUP BY CoverType, SizeClass
----------
test 3.1 using LTRIM
SELECT
SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1) as CoverType,

SUBSTR(
LTRIM(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1)),'_')
, 1, INSTR(
LTRIM(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1)),'_')
, "_")-1) as SizeClass,

SUM(case when prescription LIKE '%\_NG\_E%' ESCAPE '\' then 1 else 0 end) NG_E,
SUM(case when prescription LIKE '%\_PB\_E%' ESCAPE '\' then 1 else 0 end) PB_E,
SUM(case when prescription LIKE '%\_GS\_E%' ESCAPE '\' then 1 else 0 end) GS_E,
SUM(case when prescription LIKE '%\_EA\_E%' ESCAPE '\' then 1 else 0 end) EA_E,
SUM(case when prescription LIKE '%\_MS\_E%' ESCAPE '\' then 1 else 0 end) MS_E,
SUM(case when prescription LIKE '%\_BS\_E%' ESCAPE '\' then 1 else 0 end) BS_E,
SUM(case when SUBSTR(DISTINCT prescription, LENGTH(DISTINCT prescription), 1) LIKE 'E' then 1 else 0 end) Total_Prescriptions
FROM 
(SELECT DISTINCT prescription FROM yield_tables
WHERE prescription LIKE '%\_NG\_E%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E%' ESCAPE '\' )
GROUP BY CoverType, SizeClass
----------
test 2.0 using LTRIM
SELECT
SUBSTR(DISTINCT EA_E_prescription, 1, INSTR(DISTINCT EA_E_prescription, "_")-1) as e_covertype,

SUBSTR(
LTRIM(LTRIM(DISTINCT EA_E_prescription, SUBSTR(DISTINCT EA_E_prescription, 1, INSTR(DISTINCT EA_E_prescription, "_")-1)),'_')
, 1, INSTR(
LTRIM(LTRIM(DISTINCT EA_E_prescription, SUBSTR(DISTINCT EA_E_prescription, 1, INSTR(DISTINCT EA_E_prescription, "_")-1)),'_')
, "_")-1) as e_sizeclass,

MIN(CAST(rotation_age as decimal)) AS e_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS e_max_rotation_age
FROM 

(SELECT DISTINCT prescription AS EA_E_prescription, 
action_type AS final_activity, 
CAST(age_class as decimal) AS rotation_age
FROM yield_tables WHERE prescription LIKE '%\_EA\_E%' ESCAPE '\' GROUP BY prescription)

GROUP BY e_covertype, e_sizeclass
----------
Split into 4 columns - method 1
SELECT 
Covertype,
Sizeclass,
SUBSTR(TheRest, 1, INSTR(TheRest, '_')-1) as Method,
SUBSTR(TheRest, INSTR(TheRest, '_')+1, INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')-1) as Status,
SUBSTR(TheRest,INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')+ INSTR(TheRest, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')-1) as Sizeclass,
SUBSTR(pres,INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')+ INSTR(pres, '_')+1) as TheRest

FROM

(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E%' ESCAPE '\')
)
----------
Split into 4 columns - method 2
SELECT
Covertype,
Sizeclass,
Method,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Status,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
Sizeclass,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Method,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E\_%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E\_%' ESCAPE '\')
)
)
)
----------
3.1 Very good to use - split method 1
SELECT
Covertype,
Sizeclass,
SUM(case when Method = 'NG' AND Status = 'E' then 1 else 0 end) NG_E,
SUM(case when Method = 'PB' AND Status = 'E' then 1 else 0 end) PB_E,
SUM(case when Method = 'GS' AND Status = 'E' then 1 else 0 end) GS_E,
SUM(case when Method = 'EA' AND Status = 'E' then 1 else 0 end) EA_E,
SUM(case when Method = 'MS' AND Status = 'E' then 1 else 0 end) MS_E,
SUM(case when Method = 'BS' AND Status = 'E' then 1 else 0 end) BS_E,
SUM(case when Status = 'E' then 1 else 0 end) Total_Prescriptions


FROM


(
SELECT 
Covertype,
Sizeclass,
SUBSTR(TheRest, 1, INSTR(TheRest, '_')-1) as Method,
SUBSTR(TheRest, INSTR(TheRest, '_')+1, INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')-1) as Status,
SUBSTR(TheRest, INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')+ INSTR(TheRest, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')-1) as Sizeclass,
SUBSTR(pres, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')+ INSTR(pres, '_')+1) as TheRest

FROM

(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E\_%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E\_%' ESCAPE '\')
)
)



GROUP BY
Covertype,
Sizeclass
----------
3.1 Very good to use - split method 2 (better structure)
SELECT
Covertype,
Sizeclass,
SUM(case when Method = 'NG' AND Status = 'E' then 1 else 0 end) NG_E,
SUM(case when Method = 'PB' AND Status = 'E' then 1 else 0 end) PB_E,
SUM(case when Method = 'GS' AND Status = 'E' then 1 else 0 end) GS_E,
SUM(case when Method = 'EA' AND Status = 'E' then 1 else 0 end) EA_E,
SUM(case when Method = 'MS' AND Status = 'E' then 1 else 0 end) MS_E,
SUM(case when Method = 'BS' AND Status = 'E' then 1 else 0 end) BS_E,
SUM(case when Status = 'E' then 1 else 0 end) Total_Prescriptions
FROM



(
SELECT
Covertype,
Sizeclass,
Method,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Status,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
Sizeclass,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Method,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E\_%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E\_%' ESCAPE '\')
)
)
)
)



GROUP BY
Covertype,
Sizeclass
----------
2.0 Very good to use - split method 1
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as e_covertype,
SUBSTR(pres, INSTR(pres, '_')+1, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')-1) as e_sizeclass,
MIN(CAST(rotation_age as decimal)) AS e_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS e_max_rotation_age
FROM 

(SELECT DISTINCT prescription AS pres, 
action_type AS final_activity, 
CAST(age_class as decimal) AS rotation_age
FROM yield_tables WHERE prescription LIKE '%\_EA\_E\_%' ESCAPE '\' GROUP BY prescription)

GROUP BY e_covertype, e_sizeclass
----------
test percent rank (SQLITE 3.27 only)
SELECT 
prescription, row_id, tpa, action_type,

printf('%.2f', PERCENT_RANK() OVER
(ORDER BY CAST (tpa as decimal))) rank 
 
FROM yield_tables 
WHERE row_id = '1';
----------
test rank (SQLITE 3.27 only)
SELECT 
prescription, row_id, tpa, action_type,

RANK() OVER
(ORDER BY CAST (tpa as decimal)) rank 
 
FROM yield_tables 
WHERE row_id = '1';
----------
Show all coulmn name and type
SELECT 
ROW_NUMBER() OVER(ORDER BY name ASC) AS id, name AS attribute, type FROM PRAGMA_TABLE_INFO('yield_tables');
----------
Test recursive
Select * FROM
(          
            
WITH RECURSIVE variable(attribute) AS (SELECT name FROM PRAGMA_TABLE_INFO('yield_tables'))        
SELECT attribute FROM variable  
                              
 )
----------

SELECT table1.prescription, table1.row_id, tpa, tpa_rank, age_class, age_class_rank FROM
(

(SELECT prescription, row_id, tpa, RANK() OVER (ORDER BY CAST (tpa as decimal)) tpa_rank FROM yield_tables) table1
LEFT JOIN
(SELECT prescription, row_id, age_class, RANK() OVER (ORDER BY CAST (age_class as decimal)) age_class_rank FROM yield_tables) table2
ON table1.prescription = table2.prescription AND table1.row_id = table2.row_id


)
----------

SELECT yield_tables.prescription, yield_tables.row_id, tpa, tpa_rank, age_class, age_class_rank FROM
yield_tables

LEFT JOIN 
(SELECT prescription, row_id, RANK() OVER (ORDER BY CAST (tpa as decimal)) tpa_rank FROM yield_tables) table1
ON yield_tables.prescription = table1.prescription AND yield_tables.row_id = table1.row_id

LEFT JOIN 
(SELECT prescription, row_id, RANK() OVER (ORDER BY CAST (age_class as decimal)) age_class_rank FROM yield_tables) table2
ON yield_tables.prescription = table2.prescription AND yield_tables.row_id = table2.row_id
----------
test iterations summary
SELECT period,
SUM(CASE WHEN t.method_status = 'NGE' THEN t.grouped_area END) AS NG_E_area,
SUM(CASE WHEN t.method_status = 'PBE' THEN t.grouped_area END) AS PB_E_area,
SUM(CASE WHEN t.method_status = 'GSE' THEN t.grouped_area END) AS GS_E_area,
SUM(CASE WHEN t.method_status = 'EAE' THEN t.grouped_area END) AS EA_E_area,
SUM(CASE WHEN t.method_status = 'MSE' THEN t.grouped_area END) AS MS_E_area,
SUM(CASE WHEN t.method_status = 'BSE' THEN t.grouped_area END) AS BS_E_area,
SUM(CASE WHEN t.method_status = 'NGR' THEN t.grouped_area END) AS NG_R_area,
SUM(CASE WHEN t.method_status = 'PBR' THEN t.grouped_area END) AS PB_R_area,
SUM(CASE WHEN t.method_status = 'GSR' THEN t.grouped_area END) AS GS_R_area,
SUM(CASE WHEN t.method_status = 'EAR' THEN t.grouped_area END) AS EA_R_area
FROM


(SELECT 
CAST(var_period AS DECIMAL) as period,
(var_method || var_forest_status) AS method_status, ROUND(SUM(var_value), 1) as grouped_area
FROM output_05_management_details_0
WHERE CAST(var_period AS DECIMAL) = 1
GROUP BY (period || method_status)
ORDER BY (period || method_status)) AS t

UNION ALL

SELECT period,
SUM(CASE WHEN t.method_status = 'NGE' THEN t.grouped_area END) AS NG_E_area,
SUM(CASE WHEN t.method_status = 'PBE' THEN t.grouped_area END) AS PB_E_area,
SUM(CASE WHEN t.method_status = 'GSE' THEN t.grouped_area END) AS GS_E_area,
SUM(CASE WHEN t.method_status = 'EAE' THEN t.grouped_area END) AS EA_E_area,
SUM(CASE WHEN t.method_status = 'MSE' THEN t.grouped_area END) AS MS_E_area,
SUM(CASE WHEN t.method_status = 'BSE' THEN t.grouped_area END) AS BS_E_area,
SUM(CASE WHEN t.method_status = 'NGR' THEN t.grouped_area END) AS NG_R_area,
SUM(CASE WHEN t.method_status = 'PBR' THEN t.grouped_area END) AS PB_R_area,
SUM(CASE WHEN t.method_status = 'GSR' THEN t.grouped_area END) AS GS_R_area,
SUM(CASE WHEN t.method_status = 'EAR' THEN t.grouped_area END) AS EA_R_area
FROM


(SELECT 
CAST(var_period AS DECIMAL) as period,
(var_method || var_forest_status) AS method_status, ROUND(SUM(var_value), 1) as grouped_area
FROM output_05_management_details_1
WHERE CAST(var_period AS DECIMAL) = 1
GROUP BY (period || method_status)
ORDER BY (period || method_status)) AS t
----------
test join output_01 from 2 iterations in 2 tables
SELECT * FROM 

(SELECT description, value AS iteration_0 FROM output_01_general_outputs_0)
LEFT JOIN
(SELECT description, value AS iteration_1 FROM output_01_general_outputs_1)
USING (description)
----------
test 2 join output_01 from 2 iterations in 1 table
SELECT * FROM 

(SELECT description, value AS iteration_0 FROM summarize2_output_01_general_outputs WHERE iteration = 0)
LEFT JOIN
(SELECT description, value AS iteration_1 FROM summarize2_output_01_general_outputs WHERE iteration = 1)
USING (description)
----------