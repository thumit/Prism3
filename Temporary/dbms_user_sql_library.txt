sort yield tables
SELECT * FROM yield_tables ORDER BY prescription, CAST(row_id as decimal) ASC
----------
rename column action_type to activity in the yield_tables
ALTER TABLE yield_tables RENAME COLUMN action_type TO activity
----------
yield_tables sorted
SELECT * FROM yield_tables ORDER BY prescription, CAST(row_id as decimal) ASC
----------
test join 1
SELECT *
FROM output_05_management_details
INNER JOIN yield_tables
ON output_05_management_details.prescription = yield_tables.prescription AND output_05_management_details.row_id = yield_tables.row_id
----------
test join 2
SELECT output_05_management_details.prescription
FROM output_05_management_details
INNER JOIN yield_tables
ON output_05_management_details.prescription = yield_tables.prescription AND output_05_management_details.row_id = yield_tables.row_id
----------
vacuum
vacuum
----------
other test
SELECT
SUBSTR(prescription, 1, INSTR(prescription, "_")-1) as CoverType,
vegt

FROM yield_tables
----------
compare cover type
SELECT
SUBSTR(prescription, 1, INSTR(prescription, "_")-1) as prescription_vegt, vegt,

CASE WHEN SUBSTR(prescription, 1, INSTR(prescription, "_")-1) = vegt then 'correct' else 'fail' end AS Compare

From yield_tables;
----------
check MS prescriptions with a few information
select prescription, row_id, age_class, age, qmd, action_type from yield_tables where prescription Like '%_MS_E%'
----------
rename column row_id to row
ALTER TABLE yield_tables RENAME COLUMN row_id TO row
----------
test strata check 1 (future use in read_existig_strata)
SELECT  
COUNT (strata_id) as total_strata, 
COUNT (DISTINCT strata_id) as total_unique_strata,
CASE WHEN COUNT (strata_id) = COUNT (DISTINCT strata_id) THEN 'none - data is good' ELSE 'review duplicated strata' end AS recommendation
FROM  
(SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata)
----------
test strata check 2 (future use in : SQL library for dbms)
SELECT 
(layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, COUNT(*) as count
FROM existing_strata
GROUP BY strata_id HAVING COUNT(*) > 1
----------
test count existing_strata (simple, no use in read_existig_strata)
SELECT  COUNT (DISTINCT strata_id) as total_unique_strata
FROM  (SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata)
----------
test3 strata
SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, acres FROM  existing_strata ORDER BY (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) ASC;
----------
test-read existing strata 1
SELECT COUNT (DISTINCT strata_id) FROM (SELECT (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) as strata_id FROM existing_strata);
----------
test-read existing strata 2
SELECT * FROM existing_strata ORDER BY (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) ASC;
----------
test substring
SELECT
SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1) as CoverType,

SUBSTR(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_"))), 1, INSTR(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_"))), "_")-1) as SizeClass,

SUM(case when prescription LIKE '%\_NG\_E%' ESCAPE '\' then 1 else 0 end) NG_E,
SUM(case when prescription LIKE '%\_PB\_E%' ESCAPE '\' then 1 else 0 end) PB_E,
SUM(case when prescription LIKE '%\_GS\_E%' ESCAPE '\' then 1 else 0 end) GS_E,
SUM(case when prescription LIKE '%\_EA\_E%' ESCAPE '\' then 1 else 0 end) EA_E,
SUM(case when prescription LIKE '%\_MS\_E%' ESCAPE '\' then 1 else 0 end) MS_E,
SUM(case when prescription LIKE '%\_BS\_E%' ESCAPE '\' then 1 else 0 end) BS_E,
SUM(case when SUBSTR(DISTINCT prescription, 8, INSTR(DISTINCT prescription, "_")-1) LIKE 'E' then 1 else 0 end) Total_Prescriptions
FROM 
(SELECT DISTINCT prescription FROM yield_tables
WHERE prescription LIKE '%\_NG\_E%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E%' ESCAPE '\' )
GROUP BY CoverType, SizeClass
----------
test 3.1 using LTRIM
SELECT
SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1) as CoverType,

SUBSTR(
LTRIM(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1)),'_')
, 1, INSTR(
LTRIM(LTRIM(DISTINCT prescription, SUBSTR(DISTINCT prescription, 1, INSTR(DISTINCT prescription, "_")-1)),'_')
, "_")-1) as SizeClass,

SUM(case when prescription LIKE '%\_NG\_E%' ESCAPE '\' then 1 else 0 end) NG_E,
SUM(case when prescription LIKE '%\_PB\_E%' ESCAPE '\' then 1 else 0 end) PB_E,
SUM(case when prescription LIKE '%\_GS\_E%' ESCAPE '\' then 1 else 0 end) GS_E,
SUM(case when prescription LIKE '%\_EA\_E%' ESCAPE '\' then 1 else 0 end) EA_E,
SUM(case when prescription LIKE '%\_MS\_E%' ESCAPE '\' then 1 else 0 end) MS_E,
SUM(case when prescription LIKE '%\_BS\_E%' ESCAPE '\' then 1 else 0 end) BS_E,
SUM(case when SUBSTR(DISTINCT prescription, LENGTH(DISTINCT prescription), 1) LIKE 'E' then 1 else 0 end) Total_Prescriptions
FROM 
(SELECT DISTINCT prescription FROM yield_tables
WHERE prescription LIKE '%\_NG\_E%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E%' ESCAPE '\' )
GROUP BY CoverType, SizeClass
----------
test 2.0 using LTRIM
SELECT
SUBSTR(DISTINCT EA_E_prescription, 1, INSTR(DISTINCT EA_E_prescription, "_")-1) as e_covertype,

SUBSTR(
LTRIM(LTRIM(DISTINCT EA_E_prescription, SUBSTR(DISTINCT EA_E_prescription, 1, INSTR(DISTINCT EA_E_prescription, "_")-1)),'_')
, 1, INSTR(
LTRIM(LTRIM(DISTINCT EA_E_prescription, SUBSTR(DISTINCT EA_E_prescription, 1, INSTR(DISTINCT EA_E_prescription, "_")-1)),'_')
, "_")-1) as e_sizeclass,

MIN(CAST(rotation_age as decimal)) AS e_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS e_max_rotation_age
FROM 

(SELECT DISTINCT prescription AS EA_E_prescription, 
action_type AS final_activity, 
CAST(age_class as decimal) AS rotation_age
FROM yield_tables WHERE prescription LIKE '%\_EA\_E%' ESCAPE '\' GROUP BY prescription)

GROUP BY e_covertype, e_sizeclass
----------
Split into 4 columns - method 1
SELECT 
Covertype,
Sizeclass,
SUBSTR(TheRest, 1, INSTR(TheRest, '_')-1) as Method,
SUBSTR(TheRest, INSTR(TheRest, '_')+1, INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')-1) as Status,
SUBSTR(TheRest,INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')+ INSTR(TheRest, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')-1) as Sizeclass,
SUBSTR(pres,INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')+ INSTR(pres, '_')+1) as TheRest

FROM

(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E%' ESCAPE '\')
)
----------
Split into 4 columns - method 2
SELECT
Covertype,
Sizeclass,
Method,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Status,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
Sizeclass,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Method,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E\_%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E\_%' ESCAPE '\')
)
)
)
----------
3.1 Very good to use - split method 1
SELECT
Covertype,
Sizeclass,
SUM(case when Method = 'NG' AND Status = 'E' then 1 else 0 end) NG_E,
SUM(case when Method = 'PB' AND Status = 'E' then 1 else 0 end) PB_E,
SUM(case when Method = 'GS' AND Status = 'E' then 1 else 0 end) GS_E,
SUM(case when Method = 'EA' AND Status = 'E' then 1 else 0 end) EA_E,
SUM(case when Method = 'MS' AND Status = 'E' then 1 else 0 end) MS_E,
SUM(case when Method = 'BS' AND Status = 'E' then 1 else 0 end) BS_E,
SUM(case when Status = 'E' then 1 else 0 end) Total_Prescriptions


FROM


(
SELECT 
Covertype,
Sizeclass,
SUBSTR(TheRest, 1, INSTR(TheRest, '_')-1) as Method,
SUBSTR(TheRest, INSTR(TheRest, '_')+1, INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')-1) as Status,
SUBSTR(TheRest, INSTR(SUBSTR(TheRest, INSTR(TheRest, '_')+1), '_')+ INSTR(TheRest, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')-1) as Sizeclass,
SUBSTR(pres, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')+ INSTR(pres, '_')+1) as TheRest

FROM

(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E\_%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E\_%' ESCAPE '\')
)
)



GROUP BY
Covertype,
Sizeclass
----------
3.1 Very good to use - split method 2 (better structure)
SELECT
Covertype,
Sizeclass,
SUM(case when Method = 'NG' AND Status = 'E' then 1 else 0 end) NG_E,
SUM(case when Method = 'PB' AND Status = 'E' then 1 else 0 end) PB_E,
SUM(case when Method = 'GS' AND Status = 'E' then 1 else 0 end) GS_E,
SUM(case when Method = 'EA' AND Status = 'E' then 1 else 0 end) EA_E,
SUM(case when Method = 'MS' AND Status = 'E' then 1 else 0 end) MS_E,
SUM(case when Method = 'BS' AND Status = 'E' then 1 else 0 end) BS_E,
SUM(case when Status = 'E' then 1 else 0 end) Total_Prescriptions
FROM



(
SELECT
Covertype,
Sizeclass,
Method,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Status,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
Sizeclass,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Method,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Covertype,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\_NG\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_PB\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_GS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_EA\_E\_%' ESCAPE '\' 
OR  prescription LIKE '%\_MS\_E\_%' ESCAPE '\' 
OR prescription LIKE '%\_BS\_E\_%' ESCAPE '\')
)
)
)
)



GROUP BY
Covertype,
Sizeclass
----------
2.0 Very good to use - split method 1
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as e_covertype,
SUBSTR(pres, INSTR(pres, '_')+1, INSTR(SUBSTR(pres, INSTR(pres, '_')+1), '_')-1) as e_sizeclass,
MIN(CAST(rotation_age as decimal)) AS e_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS e_max_rotation_age
FROM 

(SELECT DISTINCT prescription AS pres, 
action_type AS final_activity, 
CAST(age_class as decimal) AS rotation_age
FROM yield_tables WHERE prescription LIKE '%\_EA\_E\_%' ESCAPE '\' GROUP BY prescription)

GROUP BY e_covertype, e_sizeclass
----------
test percent rank (SQLITE 3.27 only)
SELECT 
prescription, row_id, tpa, action_type,

printf('%.2f', PERCENT_RANK() OVER
(ORDER BY CAST (tpa as decimal))) rank 
 
FROM yield_tables 
WHERE row_id = '1';
----------
test rank (SQLITE 3.27 only)
SELECT 
prescription, row_id, tpa, action_type,

RANK() OVER
(ORDER BY CAST (tpa as decimal)) rank 
 
FROM yield_tables 
WHERE row_id = '1';
----------
Show all coulmn name and type
SELECT 
ROW_NUMBER() OVER(ORDER BY name ASC) AS id, name AS attribute, type FROM PRAGMA_TABLE_INFO('yield_tables');
----------
Test recursive
Select * FROM
(          
            
WITH RECURSIVE variable(attribute) AS (SELECT name FROM PRAGMA_TABLE_INFO('yield_tables'))        
SELECT attribute FROM variable  
                              
 )
----------

SELECT table1.prescription, table1.row_id, tpa, tpa_rank, age_class, age_class_rank FROM
(

(SELECT prescription, row_id, tpa, RANK() OVER (ORDER BY CAST (tpa as decimal)) tpa_rank FROM yield_tables) table1
LEFT JOIN
(SELECT prescription, row_id, age_class, RANK() OVER (ORDER BY CAST (age_class as decimal)) age_class_rank FROM yield_tables) table2
ON table1.prescription = table2.prescription AND table1.row_id = table2.row_id


)
----------

SELECT yield_tables.prescription, yield_tables.row_id, tpa, tpa_rank, age_class, age_class_rank FROM
yield_tables

LEFT JOIN 
(SELECT prescription, row_id, RANK() OVER (ORDER BY CAST (tpa as decimal)) tpa_rank FROM yield_tables) table1
ON yield_tables.prescription = table1.prescription AND yield_tables.row_id = table1.row_id

LEFT JOIN 
(SELECT prescription, row_id, RANK() OVER (ORDER BY CAST (age_class as decimal)) age_class_rank FROM yield_tables) table2
ON yield_tables.prescription = table2.prescription AND yield_tables.row_id = table2.row_id
----------
test iterations summary
SELECT period,
SUM(CASE WHEN t.method_status = 'NGE' THEN t.grouped_area END) AS NG_E_area,
SUM(CASE WHEN t.method_status = 'PBE' THEN t.grouped_area END) AS PB_E_area,
SUM(CASE WHEN t.method_status = 'GSE' THEN t.grouped_area END) AS GS_E_area,
SUM(CASE WHEN t.method_status = 'EAE' THEN t.grouped_area END) AS EA_E_area,
SUM(CASE WHEN t.method_status = 'MSE' THEN t.grouped_area END) AS MS_E_area,
SUM(CASE WHEN t.method_status = 'BSE' THEN t.grouped_area END) AS BS_E_area,
SUM(CASE WHEN t.method_status = 'NGR' THEN t.grouped_area END) AS NG_R_area,
SUM(CASE WHEN t.method_status = 'PBR' THEN t.grouped_area END) AS PB_R_area,
SUM(CASE WHEN t.method_status = 'GSR' THEN t.grouped_area END) AS GS_R_area,
SUM(CASE WHEN t.method_status = 'EAR' THEN t.grouped_area END) AS EA_R_area
FROM


(SELECT 
CAST(var_period AS DECIMAL) as period,
(var_method || var_forest_status) AS method_status, ROUND(SUM(var_value), 1) as grouped_area
FROM output_05_management_details_0
WHERE CAST(var_period AS DECIMAL) = 1
GROUP BY (period || method_status)
ORDER BY (period || method_status)) AS t

UNION ALL

SELECT period,
SUM(CASE WHEN t.method_status = 'NGE' THEN t.grouped_area END) AS NG_E_area,
SUM(CASE WHEN t.method_status = 'PBE' THEN t.grouped_area END) AS PB_E_area,
SUM(CASE WHEN t.method_status = 'GSE' THEN t.grouped_area END) AS GS_E_area,
SUM(CASE WHEN t.method_status = 'EAE' THEN t.grouped_area END) AS EA_E_area,
SUM(CASE WHEN t.method_status = 'MSE' THEN t.grouped_area END) AS MS_E_area,
SUM(CASE WHEN t.method_status = 'BSE' THEN t.grouped_area END) AS BS_E_area,
SUM(CASE WHEN t.method_status = 'NGR' THEN t.grouped_area END) AS NG_R_area,
SUM(CASE WHEN t.method_status = 'PBR' THEN t.grouped_area END) AS PB_R_area,
SUM(CASE WHEN t.method_status = 'GSR' THEN t.grouped_area END) AS GS_R_area,
SUM(CASE WHEN t.method_status = 'EAR' THEN t.grouped_area END) AS EA_R_area
FROM


(SELECT 
CAST(var_period AS DECIMAL) as period,
(var_method || var_forest_status) AS method_status, ROUND(SUM(var_value), 1) as grouped_area
FROM output_05_management_details_1
WHERE CAST(var_period AS DECIMAL) = 1
GROUP BY (period || method_status)
ORDER BY (period || method_status)) AS t
----------
test join output_01 from 2 iterations in 2 tables
SELECT * FROM 

(SELECT description, value AS iteration_0 FROM output_01_general_outputs_0)
LEFT JOIN
(SELECT description, value AS iteration_1 FROM output_01_general_outputs_1)
USING (description)
----------
test 2 join output_01 from 2 iterations in 1 table
SELECT * FROM 

(SELECT description, value AS iteration_0 FROM summarize2_output_01_general_outputs WHERE iteration = 0)
LEFT JOIN
(SELECT description, value AS iteration_1 FROM summarize2_output_01_general_outputs WHERE iteration = 1)
USING (description)
----------
test area solution
SELECT period,
SUM(CASE WHEN t.method_status = 'NGE' THEN t.grouped_area END) AS NG_E_area,
SUM(CASE WHEN t.method_status = 'PBE' THEN t.grouped_area END) AS PB_E_area,
SUM(CASE WHEN t.method_status = 'GSE' THEN t.grouped_area END) AS GS_E_area,
SUM(CASE WHEN t.method_status = 'EAE' THEN t.grouped_area END) AS EA_E_area,
SUM(CASE WHEN t.method_status = 'MSE' THEN t.grouped_area END) AS MS_E_area,
SUM(CASE WHEN t.method_status = 'BSE' THEN t.grouped_area END) AS BS_E_area,
SUM(CASE WHEN t.method_status = 'NGR' THEN t.grouped_area END) AS NG_R_area,
SUM(CASE WHEN t.method_status = 'PBR' THEN t.grouped_area END) AS PB_R_area,
SUM(CASE WHEN t.method_status = 'GSR' THEN t.grouped_area END) AS GS_R_area,
SUM(CASE WHEN t.method_status = 'EAR' THEN t.grouped_area END) AS EA_R_area
FROM


(SELECT 
CAST(var_period AS DECIMAL) as period,
(var_method || var_forest_status) AS method_status, ROUND(SUM(var_value), 1) as grouped_area
FROM output_05_management_details_3
GROUP BY (period || method_status)
ORDER BY (period || method_status)) AS t


GROUP BY period
----------
test summarize loss rate from all iteartions - iterration 1st
SELECT iteration, period, sr_area
FROM


(SELECT 
CAST(iteration AS DECIMAL) as iteration, 
CAST(var_period AS DECIMAL) as period, 
ROUND(SUM(var_value*loss_rate_total/100), 1) as sr_area
FROM summarize_output_05_management_details
GROUP BY (iteration || period)
)


ORDER BY iteration, period
----------
test summarize loss rate from all iteartions - period 1st
SELECT period, iteration, sr_area
FROM


(SELECT 
CAST(iteration AS DECIMAL) as iteration, 
CAST(var_period AS DECIMAL) as period, 
ROUND(SUM(var_value*loss_rate_total/100), 1) as sr_area
FROM summarize_output_05_management_details
GROUP BY (iteration || period)
)


ORDER BY period, iteration
----------
information of prescriptions
SELECT * FROM

(
SELECT DISTINCT prescription, action_type AS activity, MAX(CAST(row_id as decimal)) AS row_id, age_class, COUNT(action_type) AS total_rows
FROM yield_tables GROUP BY prescription

UNION ALL

SELECT DISTINCT prescription, action_type AS activity, MIN(CAST(row_id as decimal)) AS row_id, age_class, COUNT(action_type) AS total_rows
FROM yield_tables GROUP BY prescription
)

ORDER BY prescription, row_id
----------
information of prescriptions - details
SELECT * FROM


(
(SELECT * FROM

(
SELECT DISTINCT prescription, action_type AS activity, MAX(CAST(row_id as decimal)) AS row_id, age_class, COUNT(action_type) AS total_rows
FROM yield_tables GROUP BY prescription

UNION ALL

SELECT DISTINCT prescription, action_type AS activity, MIN(CAST(row_id as decimal)) AS row_id, age_class, COUNT(action_type) AS total_rows
FROM yield_tables GROUP BY prescription
)

ORDER BY prescription, row_id) AS t1



LEFT JOIN


(SELECT * FROM yield_tables) AS t2


ON t1.prescription = t2.prescription AND CAST(t1.row_id as decimal) = t2.row_id
)
----------
New split
SELECT
Status,
Clearcut,
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Status,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\E\_0\_%' ESCAPE '\' 
OR prescription LIKE '%\E\_1\_%' ESCAPE '\')
)
)
)
----------
new 3.0
SELECT
Covertype,
Sizeclass,
SUM(CASE when Status = 'E' AND Clearcut = '0' then 1 else 0 end) E_0_Prescriptions,
SUM(CASE when Status = 'E' AND Clearcut = '1' then 1 else 0 end) E_1_Prescriptions,
SUM(1) Total_Prescriptions
FROM



(
SELECT
Status,
Clearcut,
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Status,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables
WHERE prescription LIKE '%\E\_0\_%' ESCAPE '\' 
OR prescription LIKE '%\E\_1\_%' ESCAPE '\')
)
)
)
)



GROUP BY
Covertype,
Sizeclass




UNION ALL

SELECT
'Total_Prescriptions' as CoverType2,
'' as SizeClass2,
SUM(case when prescription LIKE '%\E\_0\_%' ESCAPE '\' then 1 else 0 end) E_0,
SUM(case when prescription LIKE '%\E\_1\_%' ESCAPE '\' then 1 else 0 end) E_1,
SUM(case when prescription LIKE '%%' then 1 else 0 end) Total_Prescriptions
FROM (SELECT DISTINCT prescription FROM yield_tables)
----------
new 3.1
SELECT
Covertype,
SUM(CASE when Status = 'E' AND Clearcut = '0' then 1 else 0 end) E_0_Prescriptions,
SUM(CASE when Status = 'E' AND Clearcut = '1' then 1 else 0 end) E_1_Prescriptions,
SUM(CASE when Status = 'R' AND Clearcut = '0' then 1 else 0 end) R_0_Prescriptions,
SUM(CASE when Status = 'R' AND Clearcut = '1' then 1 else 0 end) R_1_Prescriptions,
SUM(1) Total_Prescriptions
FROM



(
SELECT
Status,
Clearcut,
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
SUBSTR(pres, 1, INSTR(pres, '_')-1) as Status,
SUBSTR(pres, INSTR(pres, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription  as pres FROM yield_tables)
)
)
)
)



GROUP BY
Covertype
----------
new 3.1 better
SELECT
SUBSTR(DISTINCT prescription, 5, INSTR(DISTINCT prescription, "_")-1) as CoverType,
SUM(case when prescription LIKE '%\E\_0\_%' ESCAPE '\' then 1 else 0 end) E_0_Prescriptions,
SUM(case when prescription LIKE '%\E\_1\_%' ESCAPE '\' then 1 else 0 end) E_1_Prescriptions,
SUM(case when prescription LIKE '%\R\_0\_%' ESCAPE '\' then 1 else 0 end) R_0_Prescriptions,
SUM(case when prescription LIKE '%\R\_1\_%' ESCAPE '\' then 1 else 0 end) R_1_Prescriptions,
SUM(case when prescription LIKE '%%' then 1 else 0 end) Total_Prescriptions
FROM (SELECT DISTINCT prescription FROM yield_tables)
GROUP BY CoverType

UNION ALL

SELECT
'Total_Prescriptions' as CoverType2,
SUM(case when prescription LIKE '%\E\_0\_%' ESCAPE '\' then 1 else 0 end) E_0,
SUM(case when prescription LIKE '%\E\_1\_%' ESCAPE '\' then 1 else 0 end) E_1,
SUM(case when prescription LIKE '%\R\_0\_%' ESCAPE '\' then 1 else 0 end) R_0,
SUM(case when prescription LIKE '%\R\_1\_%' ESCAPE '\' then 1 else 0 end) R_1,
SUM(case when prescription LIKE '%%' then 1 else 0 end) Total_Prescriptions
FROM (SELECT DISTINCT prescription FROM yield_tables)
----------
new 2.0
SELECT
Covertype,
Sizeclass,
MIN(CAST(rotation_age as decimal)) AS E_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
Covertype,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Sizeclass,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%E\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)
)



GROUP BY Covertype, Sizeclass
----------
new 2.1
SELECT
Covertype as E_covertype,
MIN(CAST(rotation_age as decimal)) AS E_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%E\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)



GROUP BY Covertype
----------
new 2.2
SELECT
Covertype as R_covertype,
MIN(CAST(rotation_age as decimal)) AS R_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS R_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%R\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)



GROUP BY Covertype
----------
new 2.3
SELECT
e_table.Covertype,
e_table.E_min_rotation_age,
e_table.E_max_rotation_age,
r_table.R_min_rotation_age,
r_table.R_max_rotation_age
FROM
(




(SELECT
Covertype,
MIN(CAST(rotation_age as decimal)) AS E_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%E\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS e_table


LEFT JOIN


(SELECT
Covertype,
MIN(CAST(rotation_age as decimal)) AS R_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS R_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%R\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS r_table


ON e_table.Covertype = r_table.Covertype)





UNION ALL





SELECT
r_table.Covertype,
e_table.E_min_rotation_age,
e_table.E_max_rotation_age,
r_table.R_min_rotation_age,
r_table.R_max_rotation_age
FROM
(


(SELECT
Covertype,
MIN(CAST(rotation_age as decimal)) AS R_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS R_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%R\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS r_table


LEFT JOIN


(SELECT
Covertype,
MIN(CAST(rotation_age as decimal)) AS E_min_rotation_age, 
MAX(CAST(rotation_age as decimal)) AS E_max_rotation_age
FROM



(
SELECT
rotation_age,
Status,
Clearcut,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Covertype,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT
rotation_age,
Status,
SUBSTR(Leftover, 1, INSTR(Leftover, '_')-1) as Clearcut,
SUBSTR(Leftover, INSTR(Leftover, '_')+1) as Leftover
FROM

(
SELECT 
rotation_age,
SUBSTR(prescription, 1, INSTR(prescription, '_')-1) as Status,
SUBSTR(prescription, INSTR(prescription, '_')+1) as Leftover
FROM
(SELECT DISTINCT prescription, 
MAX(CAST(age_class as INTEGER)) AS rotation_age
FROM yield_tables
WHERE prescription LIKE '%E\_1\_%' ESCAPE '\' GROUP BY prescription)
)
)
)



GROUP BY Covertype) AS e_table


ON e_table.Covertype = r_table.Covertype)





WHERE  e_table.Covertype IS NULL
----------
new strata id
SELECT (layer1 || '_' || layer2 || '_' || layer3 || '_' || layer4 || '_' || layer5 || '_' || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, acres FROM  existing_strata ORDER BY (layer1 || layer2 || layer3 || layer4 || layer5 || layer6) ASC;
----------
create new existing strata table
CREATE TABLE existing_strata_new AS
SELECT (layer1 || '_' || layer2 || '_' || layer3 || '_' || layer4 || '_' || layer5 || '_' || layer6) as strata_id, layer1, layer2, layer3, layer4, layer5, layer6, acres FROM  existing_strata
----------